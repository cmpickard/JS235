<!DOCTYPE html>
<html lang="en">
<head>
  <title>Booking App</title>
  <meta charset="utf-8">
  <style>
    dl {
        border: 3px double #ccc;
        padding: 0.5em;
    }
    dt {
        float: left;
        clear: left;
        width: 100px;
        text-align: right;
        font-weight: bold;
        color: #f0595b;
    }
    dt::after {
        content: ":";
    }
    dd {
        margin: 0 0 0 110px;
        padding: 0 0 0.5em 0;
    }

    input[type="submit"] {
        color: #fff;
        background: #f0595b;
        border-color: #f0595b;
        border-radius: 5px;
        width: 100px;
        height: 50px;
    }
  </style>
  <script>
    class TimeoutError extends Error {
      constructor(message = 'Operation timed out') {
        super(message);
        this.name = 'TimeoutError';
      }
    }

    const withTimeout = (promise, delay) => {
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new TimeoutError()), delay);
      });

      return Promise.race([promise, timeoutPromise]);
    };

    function tallySchedules(schedules) {
      let tally = {};

      schedules.forEach(({ staff_id }) => {
        let key = `staff ${staff_id}`;
        tally[key] = (tally[key] || 0) + 1;
      });

      return tally;
    }

    async function retrieveSchedules() {
      try {
        let response = await withTimeout(fetch('http://localhost:3000/api/schedules'), 3000);
        let schedules = await response.json();

        if (schedules.length > 0) {
          let tally = tallySchedules(schedules);
          alert(Object.entries(tally).map(([id, count]) => `${id}: ${count}`).join('\n'));
        } else {
          alert('There are currently no schedules available for booking');
        }
      } catch (error) {
        if (error instanceof TimeoutError) {
          alert('It is taking longer than usual, please try again later.');
        } else {
          console.error(error.message);
        }
      } finally {
        alert('The request has completed.');
      }
    }

    function formDataToJson(formData) {
      return Object.fromEntries(formData.entries());
    }

    const form = document.querySelector('form');

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      const formData = new FormData(form);
      const json = JSON.stringify(formDataToJson(formData));

      let response = await fetch(form.action, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: json,
      });

      switch (response.status) {
        case 201: {
          let data = await response.json();
          alert(`Successfully created staff with id: ${data.id}`);
          form.reset();
          break;
        }
        case 400: {
          alert(await response.text());
          break;
        }
      }
    });

    let scheduleContainer;
    let btnAdd;
    form;
    let staffs;
    let scheduleCount = 0;

    async function fetchStaffMembers() {
      const response = await fetch('/api/staff_members');
      return response.json();
    }

    // Template for creating a schedule
    function scheduleTemplate() {
      const staffOptions = staffs.map(({ id, name }) =>
        `<option value="${id}">${name}</option>`).join('');

      return `
        <fieldset id="schedule_${scheduleCount}">
          <legend>Schedule ${scheduleCount}</legend>

          <div>
            <label for="staff_${scheduleCount}">Staff Name:</label>
            <select id="staff_${scheduleCount}" name="staff_${scheduleCount}">${staffOptions}</select>
          </div>

          <div>
            <label for="date_${scheduleCount}">Date:</label>
            <input type="text" id="date_${scheduleCount}" name="date_${scheduleCount}" placeholder="mm-dd-yy">
          </div>

          <div>
            <label for="time_${scheduleCount}">Time:</label>
            <input type="text" id="time_${scheduleCount}" name="time_${scheduleCount}" placeholder="hh:mm">
          </div>

        </fieldset>`;
    }

    // Add new schedule on button click
    function addSchedule() {
      scheduleCount += 1;
      const scheduleHTML = scheduleTemplate();
      scheduleContainer.insertAdjacentHTML('beforeend', scheduleHTML);
    }

    // Convert form inputs to JSON
    function formInputsToJson(form) {
      const json = [];
      for (let i = 0; i < scheduleCount; i += 1) {
        json.push({
          staff_id: form[`staff_${i + 1}`].value,
          date: form[`date_${i + 1}`].value,
          time: form[`time_${i + 1}`].value
        });
      }
      return { schedules: json };
    }

    // Handle form submission
    async function handleSubmit(event) {
      event.preventDefault();
      const json = JSON.stringify(formInputsToJson(event.target));

      const response = await fetch(event.target.action, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: json
      });

      if (response.status === 201) form.reset();
      alert(await response.text());
    }

    async function main() {
      scheduleContainer = document.getElementById('schedules');
      btnAdd = document.getElementById('btnAdd');
      form = document.querySelector('form');

      staffs = await fetchStaffMembers();

      addSchedule();

      btnAdd.addEventListener('click', event => {
        event.preventDefault();
        addSchedule();
      });

      form.addEventListener('submit', handleSubmit);
    }

    document.addEventListener('DOMContentLoaded', main);
  </script>
</head>
<body>
  <form method="post" action="/api/staff_members">
    <dl>
      <dt>
        <label for="email">Email</label>
      </dt>
      <dd>
        <input type="email" id="email" name="email">
      </dd>
      <dt>
        <label for="name">Name</label>
      </dt>
      <dd>
        <input type="text" id="name" name="name">
      </dd>
    </dl>
    <input type="submit">
  </form>
</body>
</html>
<!-- 
PART TWO:
Implement a form for adding new staff, then use the booking app API to add the
staff to the database. Your implementation should handle the different possible
responses of the server and inform the user of the outcome.

PART ONE: 
Implement a function that retrieves all the available schedules. If one or
more schedules are available, tally the count of schedules for each staff and
alert the user of the result as "key: value" pairs with the staff id as key
(in the format of 'staff {id}'; e.g, 'staff 1') and the count of schedules as
the value. If there are no schedules, alert the user that, currently, no
schedules are available for booking.

When implementing the function, keep in mind that the server has been known
to slow down when there are more than seven schedules to retrieve. It doesn't
always happen, but be sure to handle it accordingly. Once five seconds have
passed, cancel the retrieval and inform the user to try again.

Finally, inform the user about the request's completion regardless of the
request's success or failure (timeout). 

-->